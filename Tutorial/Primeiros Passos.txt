Dicas para começar:

------ Geral

- Não mexa nas coisas que mantive sem edição, voce pode adicionar mais e mexer nos que editei para fazer esse tutorial, mas mantenha os que estão por padrão, como a object results.
- Se houver um dialogo, insira na pasta Dialogues no arquivo que achar válido, ou crie um e insira lá, lembre-se, 10 idiomas, se achar cansativo peça para os tradutores do grupo fazerem, mas lembre-se, tenha pelo menos 1 dialogo, eles são feitos na seguinte forma: { "idioma": { "nomeDoDialogo": ["Mensagem1", "Mensagem2"] } }
- Se não entender, pergunte!
- Se não quiser (RECOMENDO MESMO PERGUNTAR!), leia e aprenda com os exemplos.
- Os exemplos são os comandos já feitos.
- Object não é Array, se for uma Array, escreva Array, se for uma Object, escreva Object, se for um Null, escreva Null!
- Você não precisa mexer em nada além do comando que está criando e configurar a envInfo, não se preocupe com o resto.
- Ainda que seja extremo, se puder, comente todas as linhas do código que digitar, se não puder, pode somente programar que farei os comentarios.
- A pasta deve conter o nome do comando, pois ela será usada como um alias para o mesmo.
- Se quiser inserir mais alias para seu comando, abra o arquivo symlinks.json em lib\Databases\Configurations e siga o mesmo formato dos que estão lá, lembrando, esses alias também funcionam na função Indexer.
- Basta editar o nome da pasta e já poderá colocar ela em lib\Commands para ser executada como um comando, se sua pasta se chama facebook, o comando, sem alias adicionais, vai ser exclusivamente /facebook por exemplo.

------ Index.js

- O código de javascript já tem dicas dentro e você não precisa tocar em nada além de onde está escrito que você pode, procure por "COMECE A PROGRAMAR DAQUI" para achar onde pode começar a desenvolver de imediato, mas configure a utils.json após programar seu comando.
- O sistema já está pronto para usar, todos os comandos tem sistemas isolados, então você pode usar o mesmo nome e descrição em todos sem problema, mas claro, você não vai...certo? Mantenha o código limpo, bem feito e programado, se precisar de ajuda, diga, se não puder fazer isso, programe como quiser que ajusto os detalhes finais.
- O nome da função deve ser relevante, pois ele será usado como nome da função em vez de ser uma função anonima, por exemplo, um comando de ping poderia ter o nome de pingCollector.
- Após definir o nome da função, vá até o final do código, na função resetAmbient e defina a envInfo.functions com os dados que você configurou na etapa 1.07 e 1.12, vou deixar um código pré pronto lá, apenas precisa mudar o nome e vai estar pronto, em caso de duvida, procure por "EDITE O NOME DELA AQUI", ou seja, procure pela mensagem, troque o "myFunction" pelo nome da função que escolher e voila, você terminou!
- Se você criar funções adicionais, insira elas na envInfo para acessar em outros arquivos, ou seja, todas as coisas que você inserir na envInfo podem ser acessadas por outros sistemas apenas fazendo um request com a função "Indexer".

------ .Other

- O arquivo '.other' é o nome da categoria que será usado ao consultar o menu. Por exemplo, se você renomear o arquivo '.other' para '.midia', você poderá usar '/menu midia' para visualizar seu comando criado e outros comandos do tipo mídia.
- O arquivo já inclui uma definição padrão de uso para o comando '/menu other', mas você pode personalizá-lo conforme necessário, não há um padrão, inseriu um nome = funciona.
- O menu é automaticamente construído usando um sistema baseado em Bash. Para adicionar um novo comando, basta inserir um arquivo com o nome da categoria desejada dentro da pasta. O formato do arquivo não importa, desde que ele contenha o nome da categoria.
- Você também pode filtrar comandos usando arquivos específicos, como 'utils.json' e 'index.js'. Se um arquivo estiver presente na pasta, você pode pesquisar na lista de comandos usando-o como filtro, por exemplo, '/menu utils' faria uma busca por comandos que usem JSON's.
- Seguindo um outro exemplo, para encontrar comandos que envolvam imagens, você pode simplesmente digitar '/menu jpg'. Isso fará uma busca por comandos que possuam arquivos com a extensão 'jpg' dentro da pasta, permitindo que você refine sua busca e encontre os comandos desejados de forma eficaz.

------ Utils.json

1. Abra o arquivo "utils.json", há dezenas de detalhes lá.

1.01 (Name) - Aberto o arquivo, você vai notar o name na primeira linha, isso será usado para criar uma module.exports automatica, ou seja, é de suma importancia escolher um bom nome, pois ele será parte da função, como por exemplo, se você digitasse 'Ping', a função no node automaticamente seria: functions.Ping.execute(...)
Mas não se preocupe, a exports e uso são mantidos pelo sistema de forma automatica, você não precisará tocar nisso novamente, programar com isso ou fazer algo como o exemplo acima, a menos que realmente queira.
Uso: String
Exemplo: "Ping"
Pode mexer: Sim, mas com cuidado.

1.02 (Description) - A descrição é auto explicativa, faça uma boa, pois isso estará no '--help' do comando, se caso você criar um, o começo deve ser algo que combine com 'por', pois no menu de ajuda a frase será inserida na frente dessa palavra.
Uso: String
Exemplo: "Ajudar a calcular o tempo de resposta e execução"
Pode mexer: Sim.

1.03 (Usage > General) - Isso é a forma de uso geral, um tipo de resumo, não mexa no '[Prefix][Comando]', apenas nos argumentos e valores, lembre-se de remover as explicações para não deixar o '--help' confuso.
Uso: String
Exemplo: "[Prefix][Comando] [--help|--help-dev|--show|--show --secret|None]"
Pode mexer: Somente adicionar coisas novas.

1.04 (Usage > Examples) - Aqui são as formas de uso do seu comando, você pode dar quantas quiser, mas tenha em mente que todas serão inseridas no '--help', então tente resumir.
Uso: Array de Strings
Exemplo: ["/Ping"]
Pode mexer: Somente adicionar coisas novas.

1.05 (License) - Você pode sublicenciar seu comando, como ele é parte de uma programação sua, você pode mudar a licença que esse código em especifico tem, mas adicione o arquivo de licença dentro da pasta, se quiser manter a da Íris, deixe em 'MIT'.
Uso: String
Exemplo: "MIT"
Pode mexer: Sim.

1.06 (Helps) - São as dicas do comando, mantenha as 5 primeiras, elas são as padrões.
Uso: Array de Strings
Exemplo: ["Dica ou conselho sobre como usar, efeitos ou demais"]
Pode mexer: Somente adicionar coisas novas.

1.07 (Exports) - São o nome das funções que estarão na module.exports, ou seja, lembra do exemplo do ping? A exports aqui controla o execute na frente daquele exemplo, mantenha os padrões nos mesmos valores, você somente precisa mexer nessa object se estiver adicionando uma função extra, caso contrario, deixe igual está.
Uso: Object de keys e valores que controlam a module.exports
Exemplo: { "nomeBase": "nomeReal" }
Pode mexer: Somente adicionar coisas novas.

1.08 (Developer) - Aqui você deve por seu nome, pois é onde define quem criou esse comando.
Uso: String
Exemplo: "KillovSky"
Pode mexer: Sim.

1.09 (Files) - Aqui é onde você define quais arquivos estão dentro da pasta do comando, isso é, se você adicionar algum a mais, não tem uso fora do '--help', não ainda.
Uso: Object de keys e valores que definem os arquivos da pasta
Exemplo: {"NomeDoArquivo": "Descrição do que ele faz"}
Pode mexer: Somente adicionar coisas novas.

1.11 (Modules) - Aqui é onde você define quais módulos está utilizando, incluindo os da Íris com identificação local, como a Dialogues, no caso de um - você pode trocar para _ sem problemas, o importante é só documentar, não tem uso fora do '--help', não ainda.
Uso: Object de keys e valores que definem os requires ou JSON's utilizados
Exemplo: {"NomeDoArquivo": "Descrição do que ele faz"}
Pode mexer: Somente adicionar coisas novas.

1.12 (Functions) - É aqui que a mágica acontece! Todos os parametros inseridos aqui serão utilizados para tornar a função A PROVA DE FALHAS. Isso é, são os valores por padrão, caso o enviado não seja válido, ou seja, se receber algo como null, vai pegar um valor padrão, em geral, a functions consiste nos valores abaixo, você deve manter a mesma arquitetura, usarei a messedUp de exemplo nos topicos adicionais abaixo. Mantenha as padrões, somente adicione novas.
Uso: Object com detalhes em formato de Object
Exemplo: {"nomeBase": { "arguments": { "argumentoSeHouverOuInsiraFalse": "description": "Descrição do que é esse argumento", "type": "O tipo dele", "value": "Um valor padrão, caso o usuario não envie" }, "description": "Descrição do que a função faz", "type": "O tipo de valor que vai estar nela futuramente", "value": "Um valor padrão"} }
Exemplo2: {"nomeBase": { "arguments": false, "description": "Descrição do que a função faz", "type": "O tipo de valor que vai estar nela futuramente", "value": "Um valor padrão"} }
Pode mexer: Somente adicionar coisas novas.

1.12.1 (Functions > Key) - A key da object inicial é igual ao exemplo do topico 1.07, ou seja, ele deve ser a mesma key que você definiu na exports, o nome base da função na module.exports, pegue o 'exec' da exports de exemplo.
Uso: String com mesmo nomeBase da função na module.exports
Exemplo: "parser"

1.12.2 (Functions > Key > Arguments > Key Name) - Você pode definir uma Object com os detalhes de cada argumento que sua função carrega (function (Argumentos) {...}), descrevendo eles da mesma forma que a função, no caso, o nome da key dessa Object precisa ser o nome do argumento que você importou, se você está importanto o kill, então aqui também deve ser kill.
Uso: String com mesmo nome da função importada/exportada
Exemplo: "kill"

1.12.3 (Functions > Key > Arguments > Type) - O tipo de argumento que você está recebendo, por exemplo, o kill é uma Object de funções, nesse caso, apenas digitar Object resolve, caso você insira um valor padrão diferente do que quer receber, deve inserir também isso, por exemplo, se você espera uma Object e definiu o padrão como Boolean, deve inserir aqui "Boolean / Object".
Uso: String
Exemplo: "Typeof"

1.12.4 (Functions > Key > Arguments > Value) - O valor padrão do argumento que você quer receber, caso o usuario não envie um ou você não receba um, o valor inserido aqui vai ser usado como argumento da função.
Uso: Tudo que for válido em JSON's
Exemplo: 123

1.12.5 (Functions > Key > Description) - A descrição do que sua função faz, seja breve ou não, você decide.
Uso: String
Exemplo: "Ajusta os valores de erro."

1.12.6 (Functions > Key > Type) - O tipo de valor que vai ser definido nessa função, acho que é obvio, será uma função! Mas caso não seja, defina aqui adequadamente baseando-se também no seu valor padrão abaixo.
Uso: String
Exemplo: "Boolean / Function"

1.12.7 (Functions > Key > Value) - O valor padrão, como estamos falando de functions, não dá pra inserir uma aqui sem usar o eval, que é inseguro, então deixe um false ou o que quiser, mas lembre-se, defina o tipo na Type acima.
Uso: Tudo que for válido em JSON's
Exemplo: false

1.13 (Settings) - Uma object com configurações do que cada função tem permissão ou não de fazer, como printar erros, resetar, tempo para isso, etc. Mantenha as padrões, somente adicione novas.
Uso: Object com detalhes em formato de Object
Exemplo: {"nomeDaConfig": { "description": "Descrição do que ela faz", "type": "O tipo dela", "value": "O valor padrão dessa configuração" } }
Pode mexer: Somente adicionar coisas novas.

1.13.1 (Settings > Key) - O nome da configuração, não importa para o resto do sistema, msa vai ser usado, então dê um nome coerente, ou não, você quem vai usar.
Uso: String
Exemplo: "reconnect"

1.13.2 (Settings > Key > Description) - A descrição dessa configuração, ou seja, o que ela define no seu código.
Uso: String
Exemplo: "Define se deve resetar a cada finalização."

1.13.3 (Settings > Key > Type) - O tipo de configuração que ele é, ou seja, o tipo de valor que vai hospedar nisso.
Uso: String
Exemplo: "Number"

1.13.4 (Settings > Key > Value) - O valor padrão dessa configuração, lembre-se de inserir o tipo correto no type acima.
Uso: Tudo que for válido em JSON's
Exemplo: 8000

1.14 (Parameters) - Alguns parametros adicionais em forma de Object, ou seja, códigos que não são importados, mas que são usados no código em produção como valores padrões de alguma coisa.
Uso: Object com detalhes em formato de Object
Exemplo: {"nomeDoParametro": { "description": "Descrição do que ele é", "type": "O tipo dele", "value": "O valor de fábrica dele" } }
Pode mexer: Somente adicionar coisas novas.

1.14.1 (Parameters > Key) - O nome da key deve ser o mesmo usado na variavel que você utilizar no código, por exemplo, se sua const se chama leveling, isso também deve ser leveling.
Uso: String
Exemplo: "details"

1.14.2 (Parameters > Key > Description) - A descrição desse parametro, ou seja, o que ele faz no seu código.
Uso: String
Exemplo: "Armazena a mensagem do último erro recebido."

1.14.3 (Parameters > Key > Type) - O tipo de valor que você está armazenando no parametro.
Uso: String
Exemplo: "Array"

1.14.3 (Parameters > Key > Value) - O valor padrão do seu parametro, ele pode ser editado em tempo real usando a envInfo.
Uso: Tudo que for válido em JSON's
Exemplo: { "mickeyMouse": true }

1.15 (Results) - O lugar onde o resultado final é inserido, os comandos e funções sempre retornam essa Object para quem executa, sendo assim, um await Funcao() nunca retorna um vazio, mas sim a envInfo do sistema executado.
Uso: Object com detalhes em formato de Object
Exemplo: {"description": "Descrição do que é isso", "success": "Define se foi um sucesso", "type": "Define o tipo de valor recebido", "value": "O valor retornado na execução" } }
Pode mexer: Não.

1.15.1 (Results > Description) - A descrição do que é essa object, já configurado com melhor valor.
Uso: String
Exemplo: "Armazena a mensagem do último erro recebido."

1.15.1 (Results > success) - Define se a função executou com sucesso, por padrão retorna que sim para evitar erros.
Uso: String
Exemplo: "details"

1.15.3 (Results > Type) - O tipo de valor retornado pela execução.
Uso: String
Exemplo: "Boolean"

1.15.3 (Results > Value) - O valor retornado pela execução.
Uso: Tudo que for válido em NodeJS
Exemplo: 666